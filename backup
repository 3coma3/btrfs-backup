#!/bin/bash

# BASICS -----------------------------------------------------------------------

# extended globbing is needed for argument parsing and source/filter expressions
shopt -s extglob

set -f

export script_name="$0"
export script_dir="$(dirname $(readlink -f "$0"))"

# CONFIG DECLARATION AND DEFAULTS ----------------------------------------------

# Defaults set here can be overriden at the config files passed with -c

# path to a btrfs subvolume (NOT a root volume), for snapshot storage
# you should let this script create it
export destination=''

# file globs with paths to back up
export -a sources=()

# per-source file globs with mandatory include / exclude paths
export -A filters=()

# min snapshots to keep per level (>= 0)
export -A retention=( [leafs]=15 [days]=30 [weeks]=24 [months]=12 [years]=5 )

# what to do when a snapshot is marked for rotation by the policy checks
# so far the only handlers implemented are "test" and "remove"
export rotate_action='remove'

# used in the weekly retention checks
# 1=mon, 7=sun
export weekstart=7

# can be set by passing -d on the command line, or hardcoded to ex. 'echo'
export dryrun=''

# name of a configuration file stored in the same directory as this script
# can be set by passing -c <name.conf>, or hardcoded here
export config=''

# recommended rsync flags, tune as needed
export rsyncflags='-aHAXER --numeric-ids --inplace --no-whole-file --delete-delay --force'

# USER COMMANDS ----------------------------------------------------------------
_help() {
    msg<<EOF
Usage: $script_name -h | help
       $script_name [ACTION|OPTION]...

  -h, help                  show this help

Actions can be specified multiple times:
  snap                      take a snapshot
  rotate                    apply retention policy on old snapshots
  test <n>                  test retention policy, simulating n random snapshots
  find <regex>              find snapshots whose path matches the regular expression
  remove <regex>            remove snapshots whose path matches the regular expression

Options can be specified multiple times, only the last one is taken into account:
  -c file                   configuration file to use, must exist in the same directory as this script
  -d                        dry-run mode - only show what commands would be issued
  -q                        be less verbose

EOF
}

_snap() {
    echo -e "\nBACKING UP ===="

    local base serial="$(date +%Y/%m/%d/%H%M%S)"

    if [[ ! -d "$destination" ]]; then
        # if this is the first snapshot we need to create the base subvolume
        $dryrun btrfs subvolume create "$destination"
        base="$destination"
    else
        # otherwise the base is the last snapshot under the base subvolume
        base="$destination/$(sudo btrfs subvolume list -os --sort=gen "$destination" | sed -nr '$s/^[^\/]+\/(.*)$/\1/p')"
    fi

    # create subtree for the new snapshot (yy/mm/dd branches)
    $dryrun mkdir -vp "$destination/${serial%/*}"

    # add leaf (hhmmss) as a snapshot, based on $base
    $dryrun btrfs subvolume snapshot "$base" "$destination/$serial"

    # remove from the first snapshot the copy of the initial subtree in the base
    [[ "$base" == "$destination" ]] && $dryrun rm -rfv "$destination/$serial/${serial%/*}"
    
    local -a rsyncfilters=()

    # update the new snapshot
    for source in "${sources[@]}"; do
        echo -e "\nBACKING UP $source ..."
         readarray -t rsyncfilters < <(sed '/^$/d' <<< "${filters["$source"]}")
        $dryrun rsync $rsyncflags "${rsyncfilters[@]/#/--filter=}" "$source" "$destination/$serial/"
    done
}

_clean() {
    echo -e "\nCLEANING UP ===="

    local rest y m d s cd=0 lw=0 cm=0 cy=0 cleaned=0 clean str
    while IFS='/' read rest y m d s; do
        # check retention over leaf snapshot counter (always changes)
        (( clean = retention[leafs]-- < 1 ))

        # check retention when the day has changed
        (( 10#$cd != 10#$d && (cd = 10#$d, clean &= retention[days]-- < 1) ))

        # if we are more than 6 days before the previous last day of week, check
        # week retention as this is a different week
        [[ "$lw" == "0" ]] || (( $(date -d "$lw UTC" +%s) - $(date -d "$y/$m/$d UTC" +%s) / (60 * 60 * 24) > 6 )) \
        && (( clean &= retention[weeks]-- < 1 ))

        # get last day for the week of the snapshot
        lw=$(date -d "$y/$m/$d -$(date -d $y/$m/$d +%u) days +$weekstart day" +"%F")

        # check month and year retention when they change
        (( 10#$cm != 10#$m && (cm = 10#$m, clean &= retention[months]-- < 1) ))
        (( 10#$cy != 10#$y && (cy = 10#$y, clean &= retention[years]-- < 1) ))

        (( clean )) && {
            $dryrun btrfs subvolume delete "$destination/$y/$m/$d/$s"

            # clean empty subtree
            # FIXME: output will be inaccurate in dry mode as we can't remove parents
            for dir in "$destination/"{$y/$m/$d,$y/$m,$y}; do
                [[ -z "$(ls -A "$dir")" ]] && $dryrun rmdir -v "$dir"
            done

            (( cleaned++ ))
        }
    done< <(cd "$destination" ; find . -maxdepth 4 -mindepth 4 -type d | sort -dr)

    (( cleaned == 1 )) && str=" was" || str="s were" 
    echo "$cleaned snapshot$str cleaned."
}

    }

go() {
    local token numtokens=$# skip_else
    local -a actions=() action_args=()

    while token="$1"; do
        skip_else=0
        shift

        case "$token" in
            -h|help)
                (( numtokens > 1 )) && {
                    msg<<EOF
Extra tokens on command line: ${@//${token}/}
"$token" must be passed alone, ie: $script_name $token

EOF
                    return 1
                }

                _help
                return 0
                ;;

            -c) (( $# )) || {
                    msg "Expected a config file name after -c"
                    return 1
                }

                config="$script_dir/$1"
                shift
                ;;

            -d) dryrun='echo'
                ;;

            -*) msg "Invalid option: $token"
                return 1
                ;;

            '') break
                ;;

             *) (( skip_else )) && continue
                msg "Token not recognized: $token"
                return 1
                ;;
        esac
    done

    (( ${#actions[@]} )) || {
        msg "Please specify an action, or -h for help"
        return 1
    }

    [[ -f "$config" ]] || {
        msg "Configuration file not found: \"$config\""
        return 1
    }

    . "$config"

    [[ -n "$dryrun" ]] && msg "DRY-RUN MODE: this is a simulation"

    for action in ${!actions[@]}; do
        ${actions[$action]} ${action_args[$action]}
    done
}

go $@
